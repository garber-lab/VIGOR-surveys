---
title: "Pull Survey Responses"
author: "Thomas Jacob"
date: "Created Sept 9, 2025 \nLast opened: `r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    toc: yes
---

# Initialization

```{r load_pkgs, include=TRUE}
if(!require(tidyverse)){
  install.packages("tidyverse")
  library(tidyverse)
}

if(!require(httr)){
  install.packages("httr")
  library(httr)
}

if(!require(jsonlite)){
  install.packages("jsonlite")
  library(jsonlite)
}

if(!require(here)){
  install.packages("here")
  # library(here)
}

if(!require(readxl)){
  install.packages("readxl")
  # library(readxl)
}

if(!require(knitr)){
  install.packages("knitr")
  library(knitr)
}

if(!require(DT)){
  install.packages("DT")
  library(DT)
}
library(dplyr)
library(stringr)
library(tidyr)
library(lubridate)
library(ggplot2)
library(forcats)
library(scales)
library(diptest)
library(multimode)
```


```{r set_here_root, include=FALSE}
# set the directory with the credentials file as the anchor point
here::i_am("foundry_credentials.R")
```


```{r set_credentials, include=FALSE}
# load Foundry API credentials from file
source(here::here("foundry_credentials.R"))

# load constants
source(here::here("constants.R"))

# load querying functions
source(here::here("query_functions.R"))

# load survey cleaning functions
source(here::here("surveys", "survey_functions.R"))
```


# Load Data

```{r initiate_foundry_session, include=FALSE}
token <- init_foundry_session(email=email,
                     password=password,
                     access_url = access_url)
```


```{r last_updated_pt, include=FALSE, echo=TRUE}
last_updated_fdry <- get_time_fountry_last_updated(formatted=FALSE)
last_updated_fdry_fmt <- get_time_fountry_last_updated(formatted = TRUE)
print(last_updated_fdry_fmt)
```


```{r load_participants, include=FALSE}
# pull from the API
patients_raw <- get_df(
  foundry_token = token,
  access_url_base = access_url_base,
  api_url = patients_url
)

# clean the patients DF
patients_all <- clean_patients_data(patients_raw)

# all patients who haven't withdrew
patients_clean <- patients_all %>%
  filter(studyendreason %in% c("", NA))
```


```{r load_surveys, include=FALSE}
# pull from the API
surveys_raw <- get_df(foundry_token=token,
             access_url_base=access_url_base,
             api_url=surveys_url)

surveys_clean <- clean_surveys_data(surveys_raw = surveys_raw,
                                    patients_clean = patients_clean)

# init. last updated timestamp for surveys
last_updated_surveys <- surveys_clean %>% pull(recorded_dttm) %>% max()
last_updated_surveys_fmt <- str_c("Last updated:", last_updated_surveys, current_tz, sep = " ")
print(str_c("Surveys", last_updated_surveys_fmt, sep = " "))
```


```{r load_dictionary}
# load the data dictionary
datadictionaryPath = paste( here(),"surveys", "vigor_surveys_data_dictionary.xlsx",sep = "/")
dict <- readxl::read_excel(datadictionaryPath)

data_dict_clean <- dict %>%
  rename(
    # Clean column names for easier use
    survey_type = `survey type`,
    survey_topic = `survey topic`,
    survey_display_name = `survey display name`,
    step_readable = `step readable`,
    question_readable = `result readable`,
    possible_answers = `possible answers`
  )


# display survey topic summary
survey_summary <- data_dict_clean %>%
  group_by(survey_topic, survey_type) %>%
  summarize(
    n_questions = n(),
    .groups = "drop"
  ) %>%
  arrange(survey_topic, survey_type)

kable(survey_summary,
      format = "simple",
      caption = "Survey Topics Overview",
      col.names = c("Survey Topic", "Type", "# Questions"))
```



# Main Data Processing

```{r process-non-stress-data}
# join survey responses with data dictionary
surveys_enriched_no_stress <- surveys_clean %>%
  # filter out stress surveys
  filter(str_detect(surveydisplayname, "(S|s)tress", negate = T)) %>%
  left_join(data_dict_clean,
            by = c("surveyname", "stepidentifier", "resultidentifier")) %>%
  # clean answers field (remove quotes and parse JSON-like strings)
  mutate(
    answer_clean = str_remove_all(answers, '^"|"$'),
    answer_clean = case_when(
      answer_clean == "true" ~ "Yes",
      answer_clean == "false" ~ "No",
      TRUE ~ answer_clean
    ),
    # Add time-based variables for longitudinal analysis
    days_since_enrollment = as.numeric(recorded_date - as.Date(enroll_date)),
  ) %>%
  # Filter out rows without dictionary matches (administrative surveys)
  filter(!is.na(survey_topic))  %>%
  # Select key columns for analysis
  select(
    patient_id, FamilyID, 
    # fam_pos, 
    # vit_status_exp,
    recorded_date, 
    # recorded_dttm, 
    enroll_date,
    # days_since_enrollment, 
    # survey_wave_exp, survey_period,
    survey_topic, survey_display_name, survey_type,
    # step_readable, 
    question_readable,
    answer_clean, 
    possible_answers,
    # invitation_status, enrolled, active_kitstatus
  )
```


```{r process-stress-data}
# questions needing reverse score
reverse_qs <- c(4, 5, 7, 8)

# filter for stress surveys
surveys_enriched_stress <- surveys_clean %>%
  filter(str_detect(surveydisplayname, "(S|s)tress")) %>%
  left_join(data_dict_clean %>% filter(survey_type == "QT", str_detect(surveyname, "(S|s)tress")),
            by = c("surveyname", "stepidentifier", "resultidentifier")) %>%
  # update survey type
  mutate(
    months_since_enroll = time_length(as_date(recorded_dttm) - as_date(enroll_date), unit = "month"),
    survey_type = case_when(months_since_enroll < 2.9 ~ "BL",
                            months_since_enroll >= 2.9 ~ "QT")
  ) %>%
  # clean answers field (remove quotes and parse JSON-like strings)
  mutate(
    answer_clean = str_remove_all(answers, '^"|"$'),
    answer_clean = case_when(
      answer_clean == "true" ~ "Yes",
      answer_clean == "false" ~ "No",
      TRUE ~ answer_clean
    ),
    # Add time-based variables for longitudinal analysis
    days_since_enrollment = as.numeric(recorded_date - as.Date(enroll_date)),
  ) %>%
  # Filter out rows without dictionary matches (administrative surveys)
  filter(!is.na(survey_topic))  %>%
  # compute single stress score as per PSS directions
  mutate(
    stress_score = factor(answer_clean, 
                          levels = c("never",
                                     "almost never",
                                     "sometimes",
                                     "fairly often",
                                     "very often"),
                          labels = 0:4),
    # reverse the score for Q4, 5, 7, and 8
    stress_score_v2 = case_when(
      str_extract(question_readable, "^\\d+") %in% as.character(reverse_qs) ~ fct_recode(
        stress_score,
        `0` = "4",
        `1` = "3",
        `2` = "2",
        `3` = "1",
        `4` = "0"
      ),
      .default = stress_score
    )
  ) %>%
  # replace answer_clean and possible_answers with stress scores
  mutate(
    answer_clean = stress_score_v2,
    possible_answers = str_flatten_comma(str_c(0:4))
  ) %>%
  # Select key columns for analysis
  select(
    patient_id, FamilyID, 
    # fam_pos, 
    # vit_status_exp,
    recorded_date, 
    # recorded_dttm, 
    enroll_date,
    # days_since_enrollment, 
    # survey_wave_exp, survey_period,
    survey_topic, survey_display_name, survey_type,
    # step_readable, 
    question_readable,
    answer_clean, 
    # stress_score_v2,
    possible_answers,
    # invitation_status, enrolled, active_kitstatus
  )
```


```{r process-main-data}
surveys_enriched <- bind_rows(surveys_enriched_no_stress, surveys_enriched_stress) %>%
  arrange(patient_id, recorded_date, survey_topic)

survey_topics_names <- unique(surveys_enriched$survey_topic)

cat("Enriched dataset shape:", nrow(surveys_enriched), "x", ncol(surveys_enriched), "\n")
cat("Survey topics found:", paste(survey_topics_names, collapse = ", "), "\n")
```




```{r split-into-topics}
get_topic <- function(topic) {
  
  # check if topic is valid
  if (!(topic %in% survey_topics_names)) {
    stop(
      paste0("Error: '", topic_name, "' is not a recognized survey topic. ",
             "Allowed topics are: ", paste(allowed_topics, collapse = ", "), ".")
    )
  }
  
  
  topic_df <- surveys_enriched %>%
    filter(survey_topic == topic) %>%
    select(patient_id, FamilyID, recorded_date,
           enroll_date, 
           # days_since_enrollment,
           # survey_wave, survey_period, 
           survey_type,
           question_readable,
           answer_clean)
  
  return(topic_df)
}

# create DFs for each survey topic except stress
env_df <- get_topic("environmental exposures") 
health_df <- get_topic("general health")
life_changes_df <- get_topic("life changes")
skin_type_df <- get_topic("skin type")
vitiligo_df <- get_topic("vitiligo")
stress_df <- get_topic("stress") %>%
  summarize(
    stress_score = sum(as.integer(answer_clean), na.rm = T),
    .by = c(patient_id, FamilyID, recorded_date, enroll_date, survey_type)
  )
```


```{r results='asis', echo=FALSE}
cat("
The data frame `surveys_enriched` shows all readable survey responses across all participants, timepoints, and topics, in long format.
This means every individual question response is visible, with clear labels for who answered, what, and when.

The following data frames present the same survey responses, but organized by major topic area:

* `env_df`: Environmental exposure survey responses

* `health_df`: General health and medical history responses

* `life_changes_df`: Life changes and major events responses

* `skin_type_df`: Participant skin/eye/hair characteristics (baseline only)

* `vitiligo_df`: Vitiligo-specific questions and treatments

* `stress_df`: Computed stress scores from a 10-question questionnaire (higher score = more stress)
    - This DF slightly differs from the rest...
        - Each row represents a participant's overall stress score at the time of submission (1 row per survey instead of 1 row per question)
        - The field `stress_score` replaced `answer_clean`
        - The field `question_readable` was removed

")
```

```{r vitiligo_survey}
# First clean up answers
vitiligo_df <- vitiligo_df %>%
  mutate(
    answer_clean = case_when(
      survey_type == "BL" &
        question_readable == "Have your existing spots changed in the last 3 months (shrinking or growing)?" &
        answer_clean == "no_change" ~ "no change",
      TRUE ~ answer_clean
    )
  )
```

```{r vitiligo_survey_exploratory}
answers_per_participant <- vitiligo_df %>%
  # clean blanks; treat "" and literal "NA" as missing
  mutate(answer_clean = str_squish(answer_clean),
         answer_clean = na_if(answer_clean, ""),
         answer_clean = na_if(answer_clean, "NA")) %>%
  # explode multi-selects like "Topical steroids; Phototherapy"
  separate_rows(answer_clean, sep = "\\s*[,;]\\s*") %>%
  filter(!is.na(answer_clean)) %>%
  group_by(FamilyID, patient_id) %>%
  summarise(
    n_unique_answers   = n_distinct(answer_clean),
    n_total_responses  = n(),                              # optional: total rows after splitting
    n_unique_questions = n_distinct(question_readable),    # optional: distinct questions answered
    .groups = "drop"
  ) %>%
  arrange(FamilyID, patient_id)

answers_per_participant

```
```{r plotting_vitiligo1}
# 1) Parse recorded_date to a pure Date (ignore time-of-day)
vitiligo_clean <- vitiligo_df %>%
  mutate(
    # Try multiple formats; coalesce the first that works
    rec_dt = dplyr::coalesce(
      suppressWarnings(lubridate::ymd_hms(recorded_date, quiet = TRUE)),
      suppressWarnings(lubridate::ymd(recorded_date, quiet = TRUE)),
      suppressWarnings(lubridate::mdy_hms(recorded_date, quiet = TRUE)),
      suppressWarnings(lubridate::mdy(recorded_date, quiet = TRUE)),
      suppressWarnings(lubridate::dmy_hms(recorded_date, quiet = TRUE)),
      suppressWarnings(lubridate::dmy(recorded_date, quiet = TRUE)),
      # If it's already Date/POSIXct, as_datetime/as_date will just work
      suppressWarnings(as_datetime(recorded_date))
    ),
    rec_date = as.Date(rec_dt)
  ) %>%
  filter(!is.na(rec_date))

# 2) Count distinct recorded dates per participant per question
dates_per_q <- vitiligo_clean %>%
  group_by(FamilyID, patient_id, question_readable) %>%
  summarise(n_distinct_dates = n_distinct(rec_date), .groups = "drop")

# 3) Make a nice participant label and sort by FamilyID then patient_id
dates_per_q <- vitiligo_clean %>%
  group_by(FamilyID, patient_id, question_readable) %>%
  summarise(n_distinct_dates = n_distinct(rec_date), .groups = "drop") %>%
  arrange(FamilyID, patient_id, question_readable) %>%
  mutate(
    participant_label = fct_inorder(patient_id)  # lock y-axis to current order
  )

ggplot(dates_per_q,
       aes(x = question_readable, y = participant_label, fill = n_distinct_dates)) +
  geom_tile() +
  scale_fill_gradient(name = "# distinct dates", low = "white", high = "steelblue") +
  labs(x = "Question", y = "Participant (sorted by FamilyID)") +
  theme_minimal(base_size = 11) +
  theme(axis.text.x = element_text(angle = 35, hjust = 1),
        panel.grid = element_blank())


```


Now that we have a sense of what the data is, let us try to figure out whether we got many new spots since we began

```{r plotting_vitiligo2}
vitiligo_df %>%
  filter(question_readable == "Have your existing spots changed in the last 3 months (shrinking or growing)?") %>%
  count(survey_type, answer_clean) %>%
  ggplot(aes(x = answer_clean, y = n, fill = survey_type)) +
  geom_col(position = "dodge", color = "black") +
  scale_fill_manual(values = c("BL" = "black", "QT" = "gray60")) +
  labs(x = "Answer", y = "Count") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    axis.text.x = element_text(angle = 30, hjust = 1)
  )

mode_chr <- function(x) names(which.max(table(x)))

treating_status <- vitiligo_df %>%
  filter(question_readable == "Are you currently treating your vitiligo?") %>%
  transmute(patient_id, survey_type,
            treating = case_when(
              str_to_lower(answer_clean) == "yes" ~ "Yes",
              str_to_lower(answer_clean) == "no"  ~ "No",
              TRUE ~ NA_character_
            )) %>%
  filter(!is.na(treating)) %>%
  group_by(patient_id, survey_type) %>%
  summarise(treating = mode_chr(treating), .groups = "drop")   # 1 row per person×survey

arrange(recorded_at, .by_group = TRUE) %>% slice_tail(n = 1)

plot_df <- vitiligo_df %>%
  filter(question_readable == "Have your existing spots changed in the last 3 months (shrinking or growing)?") %>%
  transmute(patient_id, survey_type,
            answer = recode(answer_clean,
                            "no_change" = "No change")) %>%      # normalize label
  left_join(treating_status, by = c("patient_id","survey_type")) %>%
  # keep all rows; mark missing treating as "Unknown" (optional)
  mutate(treating = tidyr::replace_na(treating, "Unknown")) %>%
  count(survey_type, answer, treating)

ggplot(plot_df, aes(x = answer, y = n, fill = treating)) +
  geom_col(color = "black", width = 0.8) +
  facet_wrap(~ survey_type, nrow = 1) +
  scale_fill_manual(values = c("Yes" = "black", "No" = "gray60", "Unknown" = "white")) +
  labs(x = "Answer", y = "Count", fill = "Treating?") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))


```

```{r vitiligo_new_spots, R.options=}
q1_txt  <- "Have you noticed any new white spots on your skin that you think could be vitiligo?"
q12_txt <- "Do you have vitiligo?"

norm_yesno <- function(x) {
  s <- str_to_lower(str_squish(as.character(x)))
  dplyr::case_when(
    str_detect(s, "^(yes|y|true|1)$") ~ "Yes",
    str_detect(s, "^(no|n|false|0)$") ~ "No",
    TRUE ~ NA_character_
  )
}

# --- 1) Baseline (BL) vitiligo status per participant from Q12 ---
bl_status <- vitiligo_df %>%
  filter(question_readable == q12_txt, toupper(survey_type) == "BL") %>%
  transmute(patient_id, has_vitiligo_bl = norm_yesno(answer_clean)) %>%
  distinct(patient_id, .keep_all = TRUE) %>%
  mutate(has_vitiligo_bl = fct_explicit_na(has_vitiligo_bl, "Unknown"))

# --- 2) Did they EVER report new white spots on Q1? (across BL/QT) ---
q1_ever <- vitiligo_df %>%
  filter(question_readable == q1_txt) %>%
  transmute(patient_id, q1 = norm_yesno(answer_clean)) %>%
  group_by(patient_id) %>%
  summarise(ever_yes = any(q1 == "Yes", na.rm = TRUE), .groups = "drop")

# --- 3) Join + summarise by baseline group ---
summary_df <- bl_status %>%
  full_join(q1_ever, by = "patient_id") %>%
  mutate(
    ever_yes = replace_na(ever_yes, FALSE),
    has_vitiligo_bl = fct_relevel(has_vitiligo_bl, "Yes", "No", "Unknown")
  )

yes_summary <- summary_df %>%
  group_by(has_vitiligo_bl) %>%
  summarise(
    n_total = n(),
    n_yes   = sum(ever_yes),
    pct_yes = n_yes / n_total,
    .groups = "drop"
  )

# --- 4) Plot with explicit denominators in the labels ---
ggplot(yes_summary, aes(x = has_vitiligo_bl, y = n_yes, fill = has_vitiligo_bl)) +
  geom_col(color = "black", width = 0.8) +
  geom_text(aes(label = paste0(n_yes, " / ", n_total, " (", percent(pct_yes), ")")),
            vjust = -0.35, size = 4) +
  scale_fill_manual(values = c("Yes" = "black", "No" = "gray60", "Unknown" = "white")) +
  labs(
    title = "Participants who EVER reported new white spots (Q1), by baseline vitiligo status",
    x = "Baseline vitiligo (from BL Q12)",
    y = "Number of participants"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

# --- 5) Baseline counts table you asked for ---
bl_counts <- yes_summary %>%
  select(has_vitiligo_bl, n_total) %>%
  arrange(has_vitiligo_bl)
bl_counts
```


```{r violins_bl_vs_qt_ttests_counts, message=FALSE, warning=FALSE}

q1_txt  <- "Have you noticed any new white spots on your skin that you think could be vitiligo?"
q12_txt <- "Do you have vitiligo?"

norm_yesno <- function(x) {
  s <- str_to_lower(str_squish(as.character(x)))
  dplyr::case_when(
    str_detect(s, "^(yes|y|true|1)$") ~ "Yes",
    str_detect(s, "^(no|n|false|0)$") ~ "No",
    TRUE ~ NA_character_
  )
}

# Q12 Yes on the same date
q12_yes_by_date <- vitiligo_df %>%
  filter(question_readable == q12_txt) %>%
  transmute(patient_id, recorded_date, has_vitiligo = norm_yesno(answer_clean)) %>%
  filter(has_vitiligo == "Yes") %>%
  distinct(patient_id, recorded_date)

# Q1 (new white spots) reduced to Yes/No per patient-date
q1_by_date <- vitiligo_df %>%
  filter(question_readable == q1_txt) %>%
  transmute(patient_id, recorded_date, q1_newspots = norm_yesno(answer_clean)) %>%
  filter(!is.na(q1_newspots)) %>%
  group_by(patient_id, recorded_date) %>%
  summarise(q1_newspots = ifelse(any(q1_newspots == "Yes"), "Yes", "No"),
            .groups = "drop")

# Stress on same date + tidy survey_type
stress_on_date <- stress_df %>%
  transmute(patient_id, recorded_date,
            survey_type = recode(str_to_upper(str_squish(survey_type)),
                                 "BASELINE"="BL", "QUARTERLY"="QT",
                                 "QUARTERLY CHECK-IN"="QT", "QTR"="QT",
                                 .default = str_to_upper(survey_type)),
            stress_score)

# Build analysis df: same-day Q12==Yes, Q1 answer present, stress present
anal_df <- q1_by_date %>%
  inner_join(q12_yes_by_date, by = c("patient_id","recorded_date")) %>%
  inner_join(stress_on_date,  by = c("patient_id","recorded_date")) %>%
  mutate(q1_newspots = factor(q1_newspots, levels = c("No","Yes")))

# ---- main plot (your colors, stronger box outline so median pops) ----
p <- ggplot(anal_df, aes(x = q1_newspots, y = stress_score, fill = q1_newspots)) +
  geom_violin(trim = FALSE, alpha = 0.7, width = 0.9) +
  geom_boxplot(width = 0.14, outlier.shape = NA, color = "black", linewidth = 0.5) +
  scale_fill_manual(values = c("No" = "gray60", "Yes" = "tan")) +
  facet_wrap(~ survey_type, nrow = 1) +
  scale_x_discrete(drop = FALSE) +
  labs(
    title = "Stress vs. ‘new white spots?’ by survey type (same day, Q12 = Yes)",
    x = "Answered ‘new white spots?’", y = "Stress score"
  ) +
  geom_hline(yintercept = 13, linetype = "dashed", color = "red") +
  geom_hline(yintercept = 26, linetype = "dashed", color = "blue") +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none", panel.grid.minor = element_blank()) +
  # add headroom for annotations
  scale_y_continuous(expand = expansion(mult = c(0.02, 0.18)))

# ---- add n per group per panel ----
counts <- anal_df %>%
  count(survey_type, q1_newspots, name = "n") %>%
  tidyr::complete(survey_type, q1_newspots, fill = list(n = 0)) %>%
  mutate(x = as.numeric(factor(q1_newspots, levels = c("No","Yes"))))

ymax <- anal_df %>%
  group_by(survey_type) %>%
  summarise(y_top = max(stress_score, na.rm = TRUE), .groups = "drop")

ann_n <- counts %>%
  left_join(ymax, by = "survey_type") %>%
  mutate(y = y_top + 0.05 * y_top)

p <- p + geom_text(data = ann_n,
                   aes(x = x, y = y, label = paste0("n = ", n)),
                   inherit.aes = FALSE, size = 3.3)

# ---- Welch t-tests per panel + bracketed p-values ----
# replace your format_p with a vectorized version
format_p <- function(p) {
  dplyr::case_when(
    is.na(p)        ~ "p = NA",
    p < 1e-4        ~ "p < 1e-4",
    TRUE            ~ sprintf("p = %.3f", p)
  )
}

ttests <- anal_df %>%
  group_by(survey_type) %>%
  summarise(
    n_yes = sum(q1_newspots == "Yes"),
    n_no  = sum(q1_newspots == "No"),
    p_val = {
      if (n_yes > 1 && n_no > 1) {
        out <- try(t.test(stress_score ~ q1_newspots,
                          data = cur_data(), var.equal = FALSE), silent = TRUE)
        if (inherits(out, "try-error")) NA_real_ else out$p.value
      } else NA_real_
    },
    y_top = max(stress_score, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    label  = paste0("Welch t-test, ", format_p(p_val)),
    y_bar  = y_top + 0.11 * y_top,
    y_cap  = y_bar - 0.03 * y_top
  )

# only draw brackets where both groups exist
ttests_draw <- ttests %>% filter(n_yes > 0 & n_no > 0)

p <- p +
  geom_segment(data = ttests_draw,
               aes(x = 1, xend = 2, y = y_bar, yend = y_bar),
               inherit.aes = FALSE, linewidth = 0.4) +
  geom_segment(data = ttests_draw,
               aes(x = 1, xend = 1, y = y_bar, yend = y_cap),
               inherit.aes = FALSE, linewidth = 0.4) +
  geom_segment(data = ttests_draw,
               aes(x = 2, xend = 2, y = y_bar, yend = y_cap),
               inherit.aes = FALSE, linewidth = 0.4) +
  geom_text(data = ttests_draw,
            aes(x = 1.5, y = y_bar + 0.04*y_top, label = label),
            inherit.aes = FALSE, size = 3.3)

p
```

Let us test for bimodality

```{r vitiligo_test_bimodality}
# --- helpers ---
bc_stats <- function(x) {
  x <- x[is.finite(x)]
  n <- length(x)
  if (n < 4) return(c(bc = NA_real_, skew = NA_real_, beta2 = NA_real_))
  m  <- mean(x)
  c2 <- mean((x - m)^2)
  c3 <- mean((x - m)^3)
  c4 <- mean((x - m)^4)
  skew  <- if (c2 > 0) c3 / (c2^(3/2)) else NA_real_
  beta2 <- if (c2 > 0) c4 / (c2^2) else NA_real_  # Pearson kurtosis (not "excess")
  bc    <- (skew^2 + 1) / beta2                   # Sarle's bimodality coefficient
  c(bc = bc, skew = skew, beta2 = beta2)
}

kde_modes <- function(x, bw = "SJ") {
  x <- x[is.finite(x)]
  if (length(x) < 5) return(NA_integer_)
  b <- if (bw == "SJ") bw.SJ(x) else if (bw == "nrd0") bw.nrd0(x) else bw
  d <- density(x, bw = b)
  peaks <- which(diff(sign(diff(d$y))) < 0)  # local maxima
  length(peaks)
}

# --- compute metrics per panel (BL/QT x Yes/No) ---
bimod_tbl <- anal_df %>%
  group_by(survey_type, q1_newspots) %>%
  summarise(
    n        = sum(is.finite(stress_score)),
    # Dip test (unimodality)
    dip_stat = { tmp <- dip.test(stress_score); unname(tmp$statistic) },
    dip_p    = { tmp <- dip.test(stress_score); tmp$p.value },
    # Silverman test (bootstrap KDE); skip for tiny n to keep it fast/stable
    silver_p = if (n >= 20) {
      tryCatch(
        as.numeric(modetest(stress_score, method = "SI", B = 999, k = 1)$p.value),
        error = function(e) NA_real_
      )
    } else NA_real_,
    # Bimodality coefficient
    bc       = { s <- bc_stats(stress_score); s[["bc"]] },
    # KDE peak count
    kde_modes = kde_modes(stress_score, "SJ"),
    .groups = "drop"
  ) %>%
  mutate(
    # simple flag: any one of the signals trips
    possible_bimodal = (bc > 5/9) | (!is.na(dip_p) & dip_p < 0.05) | (!is.na(silver_p) & silver_p < 0.05)
  )

bimod_tbl
```

Finally, let us see how many BL are also indicating new spots on QT

```{r bl_qt_yes_counts_and_paired_plots_v2, message=FALSE, warning=FALSE}


# ---- helpers ----
first_non_na <- function(x) x[which(!is.na(x))[1]]

# ---- per-participant flags for Q1 (using anal_df) ----
flags <- anal_df %>%
  mutate(q1_newspots = as.character(q1_newspots)) %>%
  group_by(patient_id) %>%
  summarise(
    bl_ans     = first_non_na(q1_newspots[survey_type == "BL"]),
    qt_any     = any(survey_type == "QT"),
    qt_yes     = any(survey_type == "QT" & q1_newspots == "Yes"),
    qt_no_only = qt_any & !qt_yes,
    .groups = "drop"
  ) %>%
  mutate(
    bl_ans = factor(bl_ans, levels = c("No","Yes")),
    cohort = case_when(
      bl_ans == "Yes" & qt_yes     ~ "BL Yes & QT Yes",         # A (new control)
      bl_ans == "Yes" & qt_no_only ~ "BL Yes & QT never Yes",   # B
      bl_ans == "No"  & qt_yes     ~ "BL No & QT Yes",          # C
      bl_ans == "No"  & qt_no_only ~ "BL No & QT never Yes",    # D
      bl_ans == "Yes" & !qt_any    ~ "BL Yes & No QT",
      bl_ans == "No"  & !qt_any    ~ "BL No & No QT",
      TRUE                         ~ "Incomplete"
    )
  )

# Headline counts (peek to confirm your "42")
counts <- flags %>% count(cohort, name = "n") %>% arrange(desc(n))
counts

# ---- BL/QT stress summaries ----
bl_stress <- anal_df %>%
  filter(survey_type == "BL") %>%
  group_by(patient_id) %>%
  summarise(bl_stress = median(stress_score, na.rm = TRUE), .groups = "drop")

qt_no_stress <- anal_df %>%
  filter(survey_type == "QT", q1_newspots == "No") %>%
  group_by(patient_id) %>%
  summarise(qt_no_med = median(stress_score, na.rm = TRUE), .groups = "drop")

qt_first_yes <- anal_df %>%
  filter(survey_type == "QT", q1_newspots == "Yes") %>%
  group_by(patient_id) %>%
  arrange(recorded_date, .by_group = TRUE) %>%
  slice_head(n = 1) %>%
  summarise(qt_yes_first = first(stress_score), .groups = "drop")

dat <- flags %>%
  left_join(bl_stress,    by = "patient_id") %>%
  left_join(qt_no_stress, by = "patient_id") %>%
  left_join(qt_first_yes, by = "patient_id")

# ---- build FOUR cohorts ----
cohort_A <- dat %>%                       # BL Yes & QT Yes
  filter(cohort == "BL Yes & QT Yes") %>%
  transmute(patient_id, cohort,
            phase1 = "BL (Q1=Yes)", s1 = bl_stress,
            phase2 = "QT (first Yes)", s2 = qt_yes_first)

cohort_B <- dat %>%                       # BL Yes & QT never Yes
  filter(cohort == "BL Yes & QT never Yes") %>%
  transmute(patient_id, cohort,
            phase1 = "BL (Q1=Yes)", s1 = bl_stress,
            phase2 = "QT (all No)",  s2 = qt_no_med)

cohort_C <- dat %>%                       # BL No & QT Yes
  filter(cohort == "BL No & QT Yes") %>%
  transmute(patient_id, cohort,
            phase1 = "BL (Q1=No)",  s1 = bl_stress,
            phase2 = "QT (first Yes)", s2 = qt_yes_first)

cohort_D <- dat %>%                       # BL No & QT never Yes
  filter(cohort == "BL No & QT never Yes") %>%
  transmute(patient_id, cohort,
            phase1 = "BL (Q1=No)", s1 = bl_stress,
            phase2 = "QT (all No)", s2 = qt_no_med)

paired_long <- bind_rows(cohort_A, cohort_B, cohort_C, cohort_D) %>%
  pivot_longer(c(s1, s2), names_to = "slot", values_to = "stress") %>%
  mutate(
    phase  = ifelse(slot == "s1", phase1, phase2),
    phase  = factor(phase, levels = c("BL (Q1=Yes)", "BL (Q1=No)", "QT (all No)", "QT (first Yes)")),
    cohort = factor(cohort, levels = c("BL Yes & QT Yes",
                                       "BL Yes & QT never Yes",
                                       "BL No & QT Yes",
                                       "BL No & QT never Yes"))
  ) %>%
  select(patient_id, cohort, phase, stress) %>%
  filter(is.finite(stress))

# ---- Ns and p-values per facet ----
n_phase <- paired_long %>% count(cohort, phase, name = "n")

# paired t + Wilcoxon
get_paired_tests <- function(df) {
  wide <- df %>% pivot_wider(names_from = phase, values_from = stress)
  cols <- setdiff(names(wide), "patient_id")
  if (length(cols) != 2) return(tibble(t_p = NA_real_, w_p = NA_real_))
  x <- wide[[cols[1]]]; y <- wide[[cols[2]]]  # BL first (by factor order), QT second
  tt <- try(stats::t.test(y, x, paired = TRUE), silent = TRUE)
  wx <- try(stats::wilcox.test(y, x, paired = TRUE, exact = FALSE), silent = TRUE)
  tibble(
    t_p = if (inherits(tt,"try-error")) NA_real_ else tt$p.value,
    w_p = if (inherits(wx,"try-error")) NA_real_ else wx$p.value
  )
}
tests <- paired_long %>%
  group_by(cohort) %>%
  group_modify(~ get_paired_tests(.x)) %>%
  ungroup() %>%
  mutate(
    t_lab = case_when(is.na(t_p) ~ "t: p = NA", t_p < 1e-4 ~ "t: p < 1e-4", TRUE ~ sprintf("t: p = %.3f", t_p)),
    w_lab = case_when(is.na(w_p) ~ "W: p = NA", w_p < 1e-4 ~ "W: p < 1e-4", TRUE ~ sprintf("W: p = %.3f", w_p))
  )

# ---- plot (BL left, QT right; tan=Yes, gray=No) ----
cut_low_med  <- 13
cut_med_high <- 26

y_top <- paired_long %>% group_by(cohort) %>%
  summarise(y = max(stress, na.rm = TRUE), .groups = "drop")

p <- ggplot(paired_long, aes(x = phase, y = stress, fill = phase)) +
  geom_hline(yintercept = c(cut_low_med, cut_med_high), linetype = "dashed",
             linewidth = 0.5, color = "gray30") +
  geom_line(aes(group = patient_id), color = "grey70", alpha = 0.5, linewidth = 0.4,
            position = position_jitter(width = 0.02, height = 0)) +
  geom_violin(trim = FALSE, alpha = 0.6, width = 0.9, color = "grey35") +
  geom_boxplot(width = 0.14, outlier.shape = NA, color = "black", linewidth = 0.5) +
  geom_jitter(width = 0.05, height = 0, size = 1.4, alpha = 0.55, color = "grey10") +
  scale_fill_manual(values = c("BL (Q1=Yes)" = "tan",
                               "QT (first Yes)" = "tan",
                               "BL (Q1=No)" = "gray60",
                               "QT (all No)"  = "gray60")) +
  facet_wrap(~ cohort, scales = "free_x", nrow = 1) +
  labs(
    title = "Paired stress comparisons by cohort",
    subtitle = "Cohorts include BL Yes & QT Yes as control",
    x = NULL, y = "Stress score"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none",
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 15, hjust = 1),
        plot.margin = margin(t = 10, r = 28, b = 10, l = 10)) +
  scale_y_continuous(expand = expansion(mult = c(0.02, 0.20))) +
  coord_cartesian(clip = "off")

# aligned n labels
p <- p + geom_text(data = n_phase %>% left_join(y_top, by = "cohort"),
                   aes(x = phase, y = y + 0.05*y, label = paste0("n = ", n)),
                   inherit.aes = FALSE, size = 3.1)

# p-values centered per facet
p <- p + geom_text(data = tests %>% left_join(y_top, by = "cohort"),
                   aes(x = 1.5, y = y + 0.12*y, label = paste(t_lab, "|", w_lab)),
                   inherit.aes = FALSE, size = 3.1)

p
```
