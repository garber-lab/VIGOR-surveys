---
title: "Pull Survey Responses"
author: "Thomas Jacob"
date: "Created Sept 9, 2025 \nLast opened: `r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    toc: yes
---

# Initialization

```{r load_pkgs, include=TRUE}
if(!require(tidyverse)){
  install.packages("tidyverse")
  library(tidyverse)
}

if(!require(httr)){
  install.packages("httr")
  library(httr)
}

if(!require(jsonlite)){
  install.packages("jsonlite")
  library(jsonlite)
}

if(!require(here)){
  install.packages("here")
  # library(here)
}

if(!require(readxl)){
  install.packages("readxl")
  # library(readxl)
}

if(!require(knitr)){
  install.packages("knitr")
  library(knitr)
}

if(!require(DT)){
  install.packages("DT")
  library(DT)
}
```


```{r set_here_root, include=FALSE}
# set the directory with the credentials file as the anchor point
here::i_am("foundry_credentials.R")
```


```{r set_credentials, include=FALSE}
# load Foundry API credentials from file
source(here::here("foundry_credentials.R"))

# load constants
source(here::here("constants.R"))

# load querying functions
source(here::here("query_functions.R"))

# load survey cleaning functions
source(here::here("surveys", "survey_functions.R"))
```


# Load Data

```{r initiate_foundry_session, include=FALSE}
token <- init_foundry_session(email=email,
                     password=password,
                     access_url = access_url)
```


```{r last_updated_pt, include=FALSE, echo=TRUE}
last_updated_fdry <- get_time_fountry_last_updated(formatted=FALSE)
last_updated_fdry_fmt <- get_time_fountry_last_updated(formatted = TRUE)
print(last_updated_fdry_fmt)
```


## Participants

```{r load_participants, include=FALSE}
# pull from the API
patients_raw <- get_df(
  foundry_token = token,
  access_url_base = access_url_base,
  api_url = patients_url
)

# clean the patients DF
patients_all <- clean_patients_data(patients_raw)

# all patients who haven't withdrew
patients_clean <- patients_all %>%
  filter(studyendreason %in% c("", NA))
```


## Surveys

```{r load_surveys, include=FALSE, echo=TRUE}
# pull from the API
surveys_raw <- get_df(foundry_token=token,
             access_url_base=access_url_base,
             api_url=surveys_url)

surveys_clean <- clean_surveys_data(surveys_raw = surveys_raw,
                                    patients_clean = patients_clean)

# init. last updated timestamp for surveys
last_updated_surveys <- surveys_clean %>% pull(recorded_dttm) %>% max()
last_updated_surveys_fmt <- str_c("Last updated:", last_updated_surveys, current_tz, sep = " ")
print(str_c("Surveys", last_updated_surveys_fmt, sep = " "))
```



## Data Dictionary


```{r load_dictionary, echo=TRUE}
# load the data dictionary
data_dictionary <- readxl::read_excel("vigor_surveys_data_dictionary_11SEPT2025.xlsx")


# clean and rename the columns in data dictionary for easier joining
data_dict_clean_new <- data_dictionary %>%
  rename(
    question_readable = questiontext,
    answer_format = answerformat,
    possible_answers = answerchoices
  ) %>%
  mutate(surveyversion = as.character(surveyversion)) %>%
  # create a comprehensive lookup key including version
  select(surveyname, surveyversion, stepidentifier, resultidentifier,
         survey_type, survey_topic, step_readable, question_readable,
         possible_answers)

# display survey topic and version summary
survey_summary_new <- data_dict_clean_new %>%
  group_by(survey_topic, survey_type, surveyversion) %>%
  summarize(total_questions = n(),
            .groups = "drop") %>%
  arrange(survey_topic, survey_type, desc(as.integer(surveyversion)))

kable(survey_summary_new,
      format = "simple",
      caption = "Survey Topics Overview by Type and Version",
      col.names = c("Survey Topic", "Type", "Version", "# Questions"))


# also show high-level summary w/o versions
survey_summary_no_version <- data_dict_clean_new %>%
  group_by(survey_topic, survey_type) %>%
  summarize(
    total_questions = n(),
    versions = paste(unique(surveyversion), collapse = ", "),
    .groups = "drop"
  ) %>%
  arrange(survey_topic, survey_type)

kable(survey_summary_no_version,
      format = "simple",
      caption = "Survey Topics Overview by Type (All Versions)",
      col.names = c("Survey Topic", "Type", "Total Questions", "Versions Available"))
```




# Main Data Processing



```{r process-non-stress-data}
# join survey responses with data dictionary
surveys_enriched_no_stress <- surveys_clean %>%
  # filter out stress surveys
  filter(str_detect(surveydisplayname, "(S|s)tress", negate = T)) %>%
  left_join(data_dict_clean_new,
            by = c("surveyname", "surveyversion", "stepidentifier", "resultidentifier")) %>%
  # clean answers field (remove quotes and parse JSON-like strings)
  mutate(
    answer_clean = str_remove_all(answers, '^"|"$'),
    answer_clean = case_when(
      answer_clean == "true" ~ "Yes",
      answer_clean == "false" ~ "No",
      TRUE ~ answer_clean
    ),
    # Add time-based variables for longitudinal analysis
    days_since_enrollment = as.numeric(recorded_date - as.Date(enroll_date)),
  ) %>%
  # Filter out rows without dictionary matches (administrative surveys)
  filter(!is.na(survey_topic))  %>%
  # Select key columns for analysis
  select(
    patient_id, FamilyID, 
    # fam_pos, 
    # vit_status_exp,
    recorded_date, 
    # recorded_dttm, 
    enroll_date,
    # days_since_enrollment, 
    # survey_wave_exp, survey_period,
    survey_topic, 
    survey_display_name=surveydisplayname, 
    surveyversion,
    survey_type,
    # step_readable, 
    question_readable,
    answer_clean, 
    possible_answers,
    # invitation_status, enrolled, active_kitstatus
  )
```


```{r process-stress-data}
# questions needing reverse score
reverse_qs <- c(4, 5, 7, 8)

# filter for stress surveys
surveys_enriched_stress <- surveys_clean %>%
  filter(str_detect(surveydisplayname, "(S|s)tress")) %>%
  left_join(data_dict_clean_new %>% filter(survey_type == "QT", str_detect(surveyname, "(S|s)tress")),
            by = c("surveyname", "surveyversion", "stepidentifier", "resultidentifier")) %>%
  # arrange by patient ID, recorded dttm, and question
  arrange(patient_id, recorded_dttm, question_readable) %>%
  # remove any duplicate records from the same patient on the same day 
  distinct(patient_id, recorded_date, question_readable, .keep_all = T) %>%
  # update survey type
  mutate(
    months_since_enroll = time_length(as_date(recorded_dttm) - as_date(enroll_date), unit = "month"),
    survey_type = case_when(months_since_enroll < 2.9 ~ "BL",
                            months_since_enroll >= 2.9 ~ "QT")
  ) %>%
  # clean answers field (remove quotes and parse JSON-like strings)
  mutate(
    answer_clean = str_remove_all(answers, '^"|"$'),
    answer_clean = case_when(
      answer_clean == "true" ~ "Yes",
      answer_clean == "false" ~ "No",
      TRUE ~ answer_clean
    ),
    # Add time-based variables for longitudinal analysis
    days_since_enrollment = as.numeric(recorded_date - as.Date(enroll_date)),
  ) %>%
  # Filter out rows without dictionary matches (administrative surveys)
  filter(!is.na(survey_topic))  %>%
  # compute single stress score as per PSS directions
  mutate(
    stress_score = factor(answer_clean, 
                          levels = c("never",
                                     "almost never",
                                     "sometimes",
                                     "fairly often",
                                     "very often"),
                          labels = 0:4),
    # reverse the score for Q4, 5, 7, and 8
    stress_score_v2 = case_when(
      str_extract(question_readable, "^\\d+") %in% as.character(reverse_qs) ~ fct_recode(
        stress_score,
        `0` = "4",
        `1` = "3",
        `2` = "2",
        `3` = "1",
        `4` = "0"
      ),
      .default = stress_score
    )
  ) %>%
  # replace answer_clean and possible_answers with stress scores
  mutate(
    answer_clean = stress_score_v2,
    possible_answers = str_flatten_comma(str_c(0:4))
  ) %>%
  # Select key columns for analysis
  select(
    patient_id, FamilyID, 
    # fam_pos, 
    # vit_status_exp,
    recorded_date, 
    # recorded_dttm, 
    enroll_date,
    # days_since_enrollment, 
    # survey_wave_exp, survey_period,
    survey_topic, 
    survey_display_name=surveydisplayname, 
    surveyversion,
    survey_type,
    # step_readable, 
    question_readable,
    answer_clean, 
    # stress_score_v2,
    possible_answers,
    # invitation_status, enrolled, active_kitstatus
  )
```


```{r process-main-data}
surveys_enriched <- bind_rows(surveys_enriched_no_stress, surveys_enriched_stress) %>%
  arrange(patient_id, recorded_date, survey_topic)

survey_topics_names <- unique(surveys_enriched$survey_topic)

cat("Enriched dataset shape:", nrow(surveys_enriched), "x", ncol(surveys_enriched), "\n")
cat("Survey topics found:", paste(survey_topics_names, collapse = ", "), "\n")
```




```{r split-into-topics}
get_topic <- function(topic) {
  
  # check if topic is valid
  if (!(topic %in% survey_topics_names)) {
    stop(
      paste0("Error: '", topic_name, "' is not a recognized survey topic. ",
             "Allowed topics are: ", paste(allowed_topics, collapse = ", "), ".")
    )
  }
  
  
  topic_df <- surveys_enriched %>%
    filter(survey_topic == topic) %>%
    select(patient_id, FamilyID, recorded_date,
           enroll_date, 
           # days_since_enrollment,
           # survey_wave, survey_period, 
           survey_type,
           question_readable,
           answer_clean)
  
  return(topic_df)
}

# create DFs for each survey topic except stress
env_df <- get_topic("environmental exposures") 
health_df <- get_topic("general health")
life_changes_df <- get_topic("life changes")
skin_type_df <- get_topic("skin type")
vitiligo_df <- get_topic("vitiligo")
stress_df <- get_topic("stress") %>%
  summarize(
    stress_score = sum(as.integer(answer_clean), na.rm = T),
    .by = c(patient_id, FamilyID, recorded_date, enroll_date, survey_type)
  )
```


```{r results='asis', echo=FALSE}
cat("
The data frame `surveys_enriched` shows all readable survey responses across all participants, timepoints, and topics, in long format.
This means every individual question response is visible, with clear labels for who answered, what, and when.

The following data frames present the same survey responses, but organized by major topic area:

* `env_df`: Environmental exposure survey responses

* `health_df`: General health and medical history responses

* `life_changes_df`: Life changes and major events responses

* `skin_type_df`: Participant skin/eye/hair characteristics (baseline only)

* `vitiligo_df`: Vitiligo-specific questions and treatments

* `stress_df`: Computed stress scores from a 10-question questionnaire (higher score = more stress)
    - This DF slightly differs from the rest...
        - Each row represents a participant's overall stress score at the time of submission (1 row per survey instead of 1 row per question)
        - The field `stress_score` replaced `answer_clean`
        - The field `question_readable` was removed

")
```


